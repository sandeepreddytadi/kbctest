<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <title>KBC + GLB Model Background</title>
Â  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
Â  <style>
Â  Â  body { margin: 0; overflow: hidden; font-family: 'Orbitron', sans-serif; }

Â  Â  canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }

Â  Â  .quiz-container-wrapper {
Â  Â  Â  position: absolute;
Â  Â  Â  top: 0;
Â  Â  Â  right: 0;
Â  Â  Â  width: 70%;
Â  Â  Â  height: 100%;
Â  Â  Â  background: transparent;
Â  Â  Â  padding: 30px 20px;
Â  Â  Â  z-index: 10;
Â  Â  Â  display: flex;
Â  Â  Â  justify-content: center;
Â  Â  Â  align-items: center;
Â  Â  Â  overflow-y: auto;
Â  Â  }

Â  Â  .container {
Â  Â  Â  display: none;
Â  Â  Â  flex-direction: row;
Â  Â  Â  width: 95%;
Â  Â  Â  max-width: 1200px;
Â  Â  Â  gap: 20px;
Â  Â  }

Â  Â  .welcome-screen {
Â  Â  Â  text-align: center;
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  align-items: center;
Â  Â  Â  gap: 20px;
Â  Â  Â  color: #fff;
Â  Â  }

Â  Â  .welcome-logo {
Â  Â  Â  font-size: 2em;
Â  Â  Â  color: gold;
Â  Â  }

Â  Â  .welcome-image {
Â  max-width: 100%;
Â  height: auto;
}

Â  Â  .start-btn {
Â  Â  Â  background-color: gold;
Â  Â  Â  color: black;
Â  Â  Â  font-size: 1.2em;
Â  Â  Â  font-weight: bold;
Â  Â  Â  padding: 12px 24px;
Â  Â  Â  border: none;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  cursor: pointer;
Â  Â  Â  transition: background-color 0.3s ease;
Â  Â  }

Â  Â  .start-btn:hover {
Â  Â  Â  background-color: #ffd700;
Â  Â  }

Â  Â  .game-container {
Â  Â  Â  background-color: rgba(0,0,0,0.6);
Â  Â  Â  border-radius: 10px;
Â  Â  Â  padding: 20px;
Â  Â  Â  flex: 2;
Â  Â  Â  box-shadow: 0 0 20px #ffd700;
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  justify-content: space-between;
Â  Â  Â  color: #fff;
Â  Â  }

Â  Â  /* Removed progress-bar-container and progress-bar styles */

Â  Â  .question {
Â  Â  Â  font-size: 1.5em;
Â  Â  Â  padding: 15px;
Â  Â  Â  margin-bottom: 20px;
Â  Â  Â  border: 2px solid gold;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  background-color: #002b5c;
Â  Â  Â  color: silver;
Â  Â  }

Â  Â  .options {
Â  Â  Â  display: grid;
Â  Â  Â  grid-template-columns: 1fr 1fr;
Â  Â  Â  gap: 15px;
Â  Â  Â  margin-bottom: 20px;
Â  Â  }

Â  Â  .option-btn {
Â  Â  Â  background-color: #004080;
Â  Â  Â  color: #ffffff;
Â  Â  Â  border: 2px solid gold;
Â  Â  Â  padding: 15px;
Â  Â  Â  padding: 12px;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  cursor: pointer;
Â  Â  Â  font-weight: bold;
Â  Â  Â  transition: 0.3s;
Â  Â  }

Â  Â  .option-btn:hover {
Â  Â  Â  background-color: #0059b3;
Â  Â  }

Â  Â  .option-btn:disabled {
Â  Â  Â  opacity: 0.5;
Â  Â  Â  cursor: not-allowed;
Â  Â  }

Â .actions {
Â  Â  Â  display: flex;
Â  Â  Â  justify-content: space-between;
Â  Â  Â  gap: 10px;
Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  flex-wrap: wrap;
Â  Â  }

Â .action-btn {
Â  Â  Â  background-color: gold;
Â  Â  Â  color: black;
Â  Â  Â  font-weight: bold;
Â  Â  Â  border: none;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  padding: 8px 12px;
Â  Â  Â  cursor: pointer;
Â  Â  Â  flex: 1;
Â  Â  Â  transition: background-color 0.3s ease;
Â  Â  }

Â .action-btn:hover {
Â  Â  Â  background-color: #ffd700;
Â  Â  }

Â  Â  .top-bar {
Â  Â  Â  display: flex;
Â  Â  Â  justify-content: space-between;
Â  Â  Â  align-items: center;
Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  font-size: 1.2em;
Â  Â  Â  color: #ffd700;
Â  Â  }

Â  Â  .final-congrats {
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  align-items: center;
Â  Â  Â  text-align: center;
Â  Â  Â  color: gold;
Â  Â  Â  padding: 20px;
Â  Â  }

Â  Â  .final-badge {
Â  Â  Â  font-size: 1.5em;
Â  Â  Â  font-weight: bold;
Â  Â  Â  background-color: gold;
Â  Â  Â  color: black;
Â  Â  Â  padding: 15px 30px;
Â  Â  Â  border-radius: 12px;
Â  Â  Â  border: 3px solid white;
Â  Â  Â  margin-top: 20px;
Â  Â  }

Â  Â  .instructions {
Â  Â  Â  position: absolute;
Â  Â  Â  bottom: 20px;
Â  Â  Â  left: 20px;
Â  Â  Â  color: #ffd700;
Â  Â  Â  font-size: 0.9em;
Â  Â  Â  z-index: 20;
Â  Â  }
Â  </style>

Â  <script type="importmap">
Â  Â  {
Â  Â  Â  "imports": {
Â  Â  Â  Â  "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
Â  Â  Â  Â  "GLTFLoader": "https://unpkg.com/three@0.154.0/examples/jsm/loaders/GLTFLoader.js",
Â  Â  Â  Â  "OrbitControls": "https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js"
Â  Â  Â  }
Â  Â  }
Â  </script>
</head>
<body>

Â  <script type="module">
Â  Â  import * as THREE from 'three';
Â  Â  import { TextureLoader } from 'three';
Â  Â  import { GLTFLoader } from 'GLTFLoader';
Â  Â  import { OrbitControls } from 'OrbitControls';

Â  Â  let scene, camera, renderer, mixer, clock;
Â  Â  let waitingForNext = false;
Â  Â  let action1, action2;
Â  Â  let dollAnimationState = 'idle'; // idle, animating, waiting

Â  Â  window.dollController = {
Â  Â  Â  playAction1: function() {
Â  Â  Â  Â  if (!mixer || !action1 || dollAnimationState === 'animating') return;
Â  Â  Â  Â  dollAnimationState = 'animating';
Â  Â  Â  Â  if (action2) action2.stop();
Â  Â  Â  Â  action1.reset();
Â  Â  Â  Â  action1.setLoop(THREE.LoopOnce);
Â  Â  Â  Â  action1.clampWhenFinished = true;
Â  Â  Â  Â  action1.play();
Â  Â  Â  Â  // Play green light sound
Â  Â  Â  Â  if (window.soundGreenLight) {
Â  Â  Â  Â  Â  window.soundGreenLight.currentTime = 0;
Â  Â  Â  Â  Â  window.soundGreenLight.play().catch(() => {});
Â  Â  Â  Â  }
Â  Â  Â  Â  // Listen for animation completion
Â  Â  Â  Â  mixer.addEventListener('finished', function onFinished(e) {
Â  Â  Â  Â  Â  if (e.action === action1) {
Â  dollAnimationState = 'waiting';
Â  mixer.removeEventListener('finished', onFinished);
Â  // Start looping idle sound
Â  if (window.soundDollIdleLoop) {
Â  Â  window.soundDollIdleLoop.currentTime = 0;
Â  Â  window.soundDollIdleLoop.play().catch(() => {});
Â  }
}
Â  Â  Â  Â  });
Â  Â  Â  },
Â  Â  Â  playAction2: function() {
Â  Â  Â  Â  if (!mixer || !action2 || dollAnimationState === 'animating') return;
Â  Â  Â  Â  dollAnimationState = 'animating';
Â  Â  Â  Â  if (action1) action1.stop();
Â  Â  Â  Â  action2.reset();
Â  Â  Â  Â  action2.setLoop(THREE.LoopOnce);
Â  Â  Â  Â  action2.clampWhenFinished = true;
Â  Â  Â  Â  action2.play();
Â  Â  Â  Â  // Stop idle loop sound before red light
if (window.soundDollIdleLoop) {
Â  window.soundDollIdleLoop.pause();
Â  window.soundDollIdleLoop.currentTime = 0;
}
Â  Â  Â  Â  // Play red light sound
Â  Â  Â  Â  if (window.soundRedLight) {
Â  Â  Â  Â  Â  window.soundRedLight.currentTime = 0;
Â  Â  Â  Â  Â  window.soundRedLight.play().catch(() => {});
Â  Â  Â  Â  }
Â  Â  Â  Â  // Listen for animation completion
Â  Â  Â  Â  mixer.addEventListener('finished', function onFinished(e) {
Â  Â  Â  Â  Â  if (e.action === action2) {
Â  Â  Â  Â  Â  Â  dollAnimationState = 'idle';
Â  Â  Â  Â  Â  Â  mixer.removeEventListener('finished', onFinished);
Â  Â  Â  Â  Â  Â  // Trigger question load after 3 seconds
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  if (window.gameController) {
Â  Â  Â  Â  Â  Â  Â  Â  window.gameController.loadQuestionAfterDoll();
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }, 3000);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  },
Â  Â  Â  getState: function() {
Â  Â  Â  Â  return dollAnimationState;
Â  Â  Â  }
Â  Â  };

Â  Â  init();
Â  Â  animate();

Â  Â  function init() {
Â  Â  Â  clock = new THREE.Clock();
Â  Â  Â  scene = new THREE.Scene();
Â  Â  Â  const textureLoader = new THREE.TextureLoader();
textureLoader.load('background.jpg', function(texture) {
Â  scene.background = texture;
});

Â  Â  Â  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
Â  Â  Â  camera.position.set(0, 5, 20);

Â  Â  Â  renderer = new THREE.WebGLRenderer({ antialias: true });
Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  document.body.appendChild(renderer.domElement);

Â  Â  Â  const controls = new OrbitControls(camera, renderer.domElement);
Â  Â  Â  controls.target.set(0, 5, 0);
Â  Â  Â  controls.update();

Â  Â  Â // Soft ambient light for general illumination
const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambientLight);

// Main front-facing directional light (perfectly centered)
const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(10, 0, 0); // straight in front of doll
directionalLight.target.position.set(0, 0, 0); // center of scene (doll)
scene.add(directionalLight);
scene.add(directionalLight.target);

// Optional: Hemisphere for smoother overall look
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x333333, 0.2);
scene.add(hemiLight);


Â  Â  Â  const loader = new GLTFLoader();
Â  Â  Â  loader.load('doll.glb', function (gltf) {
Â  Â  Â  Â  const model = gltf.scene;
Â  Â  Â  Â  scene.add(model);

Â  Â  Â  Â  const exportedCameras = gltf.cameras;
Â  Â  Â  Â  if (exportedCameras && exportedCameras.length > 0) {
Â  Â  Â  Â  Â  camera = exportedCameras[0];
Â  Â  Â  Â  }

Â  Â  Â  Â  mixer = new THREE.AnimationMixer(model);
Â  Â  Â  Â  const animations = gltf.animations;

Â  Â  Â  Â  action1 = mixer.clipAction(animations.find(a => a.name === "o to 18o degree"));
Â  Â  Â  Â  action2 = mixer.clipAction(animations.find(a => a.name === "18o to o degree"));
Â  Â  Â  }, undefined, function (error) {
Â  Â  Â  Â  console.log('GLB file not found, continuing without 3D model');
Â  Â  Â  });

Â  Â  Â  window.addEventListener('resize', () => {
Â  Â  Â  Â  camera.aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  camera.updateProjectionMatrix();
Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  });

Â  Â  Â  window.addEventListener('keydown', (event) => {
Â  Â  Â  Â  if (!mixer || !action1 || !action2) return;
Â  Â  Â  Â  if (event.key.toLowerCase() === 'r' && dollAnimationState === 'waiting') {
Â  Â  Â  Â  Â  window.dollController.playAction2();
Â  Â  Â  Â  Â  if (window.gameController) {
Â  Â  Â  Â  Â  Â  window.gameController.showDollSeeingMessage();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }
Â  Â  function animate() {
Â  Â  Â  requestAnimationFrame(animate);
Â  Â  Â  const delta = clock.getDelta();
Â  Â  Â  if (mixer) mixer.update(delta);
Â  Â  Â  renderer.render(scene, camera);
Â  Â  }
Â  </script>

Â  <div class="quiz-container-wrapper">
Â  Â  <div class="welcome-screen" id="welcome-screen">
Â  Â  Â  <div class="welcome-logo"> AI'ce breaker event - Giggles Galore</div>
Â  Â  Â  <img src="welcome.png" alt="Welcome Image" class="welcome-image">
Â  Â  Â  <button class="start-btn" onclick="startGame()">Start Game</button>
Â  Â  </div>

Â  Â  <div class="container" id="game-container">
Â  Â  Â  <div class="game-container">
Â  Â  Â  Â  <div class="top-bar">
Â  Â  Â  Â  Â  <div id="timer">â±ï¸ 30s</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="question" id="question">Loading...</div>
Â  Â  Â  Â  <div class="options" id="options"></div>
Â  Â  Â  Â  <div class="actions">
Â  Â  Â  Â  Â  <button class="action-btn" onclick="restartGame()">Restart</button>
Â  Â  Â  Â  Â  <button class="action-btn" onclick="quitGame()">Quit</button>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>

Â  <div class="instructions">
Â  Â  <span>Press **S** to start, **A/B/C/D** to answer, **N** for next question, or **Q** to quit.</span>
Â  </div>

Â  <audio id="soundQuestion" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
Â  <audio id="soundCorrect" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
Â  <audio id="soundWrong" src="audio/squid-game-gunshot.mp3" preload="auto"></audio>
Â  <audio id="soundGreenLight" src="audio/doll-green-light.mp3" preload="auto"></audio>
Â  <audio id="soundRedLight" src="audio/doll-red-light.mp3" preload="auto"></audio>
Â  <audio id="soundIntro" src="audio/squid-game-rules.mp3" preload="auto"></audio>
Â  <audio id="soundDollIdleLoop" src="audio/squid-game.mp3" preload="auto" loop></audio>

Â  <script>
Â  Â  const allQuestions = [
Â  { q: "What does GPT stand for?", a: ["Global Processing Tool", "Generative Pre trained Transformer", "General Purpose Technology", "Graphic Programming Template"], c: 1 },

Â  { q: "What should organization consider before implementing AI?", a: ["Ethics, privacy and accuracy", "Only the cost savings", "Only the speed improvements", "Only employee reactions"], c: 0 },

Â  { q: "What is neural network inspired by?", a: ["The human brain", "Telephone networks", "Road systems", "Computer Circuits"], c: 0 },

Â  { q: "What is 'Deep Learning' a subset of?", a: ["Expert Systems", "Machine Vision", "Robotics", "Machine Learning"], c: 3 },

Â  { q: "Which company developed GPT-4?", a: ["Meta", "Google", "IBM", "OpenAI"], c: 3 },

Â  { q: "What does AI stand for?", a: ["Analog Input", "Artificial Intelligence", "Automated Input", "Advanced Interface"], c: 1 },

Â  { q: "NLP stands for?", a: ["None", "Net Language Python", "Natural Language Processing", "Neural LP"], c: 2 },

Â  { q: "What type of content can Generative AI create?", a: ["Only Images", "Only Texts", "Only computer programs", "Texts, Images, Music and Code"], c: 3 },

Â  { q: "What does 'LLM' stand for in AI?", a: ["Large Learning Machine", "Large Learning Model", "Large Language Model", "Large Language Module"], c: 2 },

Â  { q: "GAN stands for?", a: ["Generative Adversarial Network", "Generic AI Node", "Graphical AI Network", "General Adv Network"], c: 0 }
];

Â  Â  let questions, currentIndex = 0, timer, timeLeft = 30;
Â  Â  let waitingForNext = false;
Â  Â  let quizActive = false;
Â  Â  let waitingForDoll = false;
Â  Â  let introOver = false;

Â  Â  const questionEl = document.getElementById("question");
Â  Â  const optionsEl = document.getElementById("options");
Â  Â  const timerEl = document.getElementById("timer");
Â  Â  const soundCorrect = document.getElementById("soundCorrect");
Â  Â  const soundWrong = document.getElementById("soundWrong");
Â  Â  const soundQuestion = document.getElementById("soundQuestion");
Â  Â  const soundIntro = document.getElementById("soundIntro");

Â  Â  window.gameController = {
Â  Â  Â  showDollSeeingMessage: function() {
Â  Â  Â  Â  questionEl.textContent = "ğŸ” Doll is Watching...";
Â  Â  Â  Â  optionsEl.innerHTML = "";
Â  Â  Â  Â  clearInterval(timer);
Â  Â  Â  Â  timerEl.textContent = "";
Â  Â  Â  },

Â  Â  Â  loadQuestionAfterDoll: function() {
Â  Â  Â  Â  if (waitingForDoll) {
Â  Â  Â  Â  Â  waitingForDoll = false;
Â  Â  Â  Â  Â  loadQuestion();
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  };

Â  Â  // Define a function to initialize game state and start doll animation for the first question
Â  Â  const initializeGameForQuestion = () => {
Â  Â  Â  Â  // Reset game state for a new round of questions
Â  Â  Â  Â  questions = [...allQuestions];
Â  Â  Â  Â  currentIndex = 0;
Â  Â  Â  Â  quizActive = true;
Â  Â  Â  Â  waitingForDoll = false; // Reset this state

Â  Â  Â  Â  // Clear any active timers from a previous game
Â  Â  Â  Â  clearInterval(timer);
Â  Â  Â  Â  timerEl.textContent = ""; // Clear timer display

Â  Â  Â  Â  // Start the doll animation (which includes green light sound)
Â  Â  Â  Â  questionEl.textContent = "Loading..."; // Displays "Loading..." before doll turns
Â  Â  Â  Â  optionsEl.innerHTML = "";
Â  Â  Â  Â  if (window.dollController) {
Â  Â  Â  Â  Â  Â  window.dollController.playAction1();
Â  Â  Â  Â  }
Â  Â  Â  Â  waitingForDoll = true;
Â  Â  };

function startGame() {
Â  document.getElementById("welcome-screen").style.display = "none";
Â  document.getElementById("game-container").style.display = "flex";

Â  // Show rules text only â€” no audio
Â  questionEl.textContent = "ğŸ”Š Rules...";
Â  optionsEl.innerHTML = "";

Â  introOver = true;
}

Â  Â Â 
window.addEventListener('keydown', (e) => {
Â  // Start Game
Â  if (e.key.toLowerCase() === 's' && document.getElementById("welcome-screen").style.display !== "none") {
Â  Â  startGame();
Â  }

Â  // Next Question
Â  if (e.key.toLowerCase() === 'n') {
Â  Â  if (!quizActive && introOver) {
Â  Â  Â  introOver = false;
Â  Â  Â  initializeGameForQuestion();
Â  Â  } else if (waitingForNext) {
Â  Â  Â  if (currentIndex + 1 >= questions.length) {
Â  Â  Â  Â  // All questions completed
Â  Â  Â  Â  quizActive = false;
Â  Â  Â  Â  waitingForNext = false;
Â  Â  Â  Â  questionEl.textContent = "Successfully Completed Quiz. Thank you for Participating!";
Â  Â  Â  Â  optionsEl.innerHTML = "";
Â  Â  Â  Â  timerEl.textContent = "";
Â  Â  Â  } else {
Â  Â  Â  Â  waitingForNext = false;
Â  Â  Â  Â  currentIndex++;
Â  Â  Â  Â  questionEl.textContent = "Loading...";
Â  Â  Â  Â  optionsEl.innerHTML = "";
Â  Â  Â  Â  timerEl.textContent = "";
Â  Â  Â  Â  if (window.dollController) {
Â  Â  Â  Â  Â  window.dollController.playAction1();
Â  Â  Â  Â  }
Â  Â  Â  Â  waitingForDoll = true;
Â  Â  Â  }
Â  Â  }
Â  }

Â  // Quit Game
Â  if (e.key.toLowerCase() === 'q') {
Â  Â  quitGame();
Â  }

Â  // Answer options
Â  if (quizActive && !waitingForNext) {
Â  Â  const key = e.key.toLowerCase();
Â  Â  let optionIndex = -1;
Â  Â  if (key === 'a' && optionsEl.children[0]) {
Â  Â  Â  optionIndex = 0;
Â  Â  } else if (key === 'b' && optionsEl.children[1]) {
Â  Â  Â  optionIndex = 1;
Â  Â  } else if (key === 'c' && optionsEl.children[2]) {
Â  Â  Â  optionIndex = 2;
Â  Â  } else if (key === 'd' && optionsEl.children[3]) {
Â  Â  Â  optionIndex = 3;
Â  Â  }

Â  Â  if (optionIndex !== -1) {
Â  Â  Â  handleAnswer(optionIndex);
Â  Â  }
Â  }
});


Â  Â  window.addEventListener('touchend', (e) => {
Â  const tappedElement = e.target;

Â  // Start quiz on tap of canvas (only if introOver is true)
Â  if (introOver && tappedElement.tagName.toLowerCase() === 'canvas') {
Â  Â  introOver = false;
Â  Â  initializeGameForQuestion();
Â  Â  return;
Â  }

Â  // Advance to next question on tap outside canvas
Â  if (waitingForNext && tappedElement.tagName.toLowerCase() !== 'canvas') {
Â  Â  if (currentIndex + 1 >= questions.length) {
Â  Â  Â  // All questions completed
Â  Â  Â  quizActive = false;
Â  Â  Â  waitingForNext = false;
Â  Â  Â  questionEl.textContent = "Successfully Completed Quiz. Thank you for Participating!";
Â  Â  Â  optionsEl.innerHTML = "";
Â  Â  Â  timerEl.textContent = "";
Â  Â  } else {
Â  Â  Â  waitingForNext = false;
Â  Â  Â  currentIndex++;
Â  Â  Â  questionEl.textContent = "Loading...";
Â  Â  Â  optionsEl.innerHTML = "";
Â  Â  Â  timerEl.textContent = "";
Â  Â  Â  if (window.dollController) {
Â  Â  Â  Â  window.dollController.playAction1();
Â  Â  Â  }
Â  Â  Â  waitingForDoll = true;
Â  Â  }
Â  }
});



Â  Â  // Removed updateProgress() function as progress bar is removed

Â  Â  function loadQuestion() {
Â  Â  Â  clearInterval(timer);

Â  Â  Â  // If we've exhausted all unique questions, reset currentIndex to 0 to loop
Â  Â  Â  if (currentIndex >= questions.length) {
Â  Â  Â  Â  currentIndex = 0; // Loop back to the first question
Â  Â  Â  Â  // Optionally, reshuffle here if you want a new random order after a full cycle
Â  Â  Â  Â  // questions = [...allQuestions].sort(() => 0.5 - Math.random());
Â  Â  Â  }

Â  Â  Â  const q = questions[currentIndex];
Â  Â  Â  timeLeft = 30;
Â  Â  Â  updateTimer();
Â  Â  Â  timer = setInterval(() => {
Â  Â  Â  Â  timeLeft--;
Â  Â  Â  Â  updateTimer();
Â  Â  Â  Â  if (timeLeft <= 0) endGame("â±ï¸ Time's up!"); // Still ends game on time out
Â  Â  Â  }, 1000);

Â  Â  Â  questionEl.textContent = q.q;
Â  Â  Â  optionsEl.innerHTML = "";

Â  Â  Â  soundQuestion.currentTime = 0;
Â  Â  Â  soundQuestion.play().catch(() => {});

Â  Â  Â  q.a.forEach((option, i) => {
Â  Â  Â  Â  const btn = document.createElement("button");
Â  Â  Â  Â  btn.className = "option-btn";
Â  Â  Â  Â  btn.textContent = option;
Â  Â  Â  Â  btn.onclick = () => handleAnswer(i);
Â  Â  Â  Â  optionsEl.appendChild(btn);
Â  Â  Â  });
Â  Â  }

Â  Â  function handleAnswer(i) {
Â  Â  Â  clearInterval(timer);
Â  Â  Â  const correct = questions[currentIndex].c;
Â  Â  Â  const btns = optionsEl.querySelectorAll("button");
Â  Â  Â  btns.forEach((btn, index) => {
Â  Â  Â  Â  btn.disabled = true;
Â  Â  Â  Â  if (index === correct) {
Â  Â  Â  Â  Â  btn.style.backgroundColor = "#28a745";
Â  Â  Â  Â  } else if (index === i) {
Â  Â  Â  Â  Â  btn.style.backgroundColor = "#dc3545";
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  if (i === correct) {
Â  Â  Â  Â  soundCorrect.currentTime = 0;
Â  Â  Â  Â  soundCorrect.play().catch(() => {});
Â  Â  Â  } else {
Â  Â  Â  Â  soundWrong.currentTime = 0;
Â  Â  Â  Â  soundWrong.play().catch(() => {});
Â  Â  Â  }
Â  Â  Â  // Set flag to wait for 'N' key
Â  Â  Â  waitingForNext = true;
Â  Â  }

Â  Â  function updateTimer() {
Â  Â  Â  timerEl.textContent = `â±ï¸ ${timeLeft}s`;
Â  Â  }

Â  Â  function endGame(msg) {
Â  Â  Â  clearInterval(timer);
Â  Â  Â  timerEl.textContent = msg;
Â  Â  Â  quizActive = false;
Â  Â  Â  waitingForDoll = false;
Â  Â  }
const soundDollIdleLoop = document.getElementById('soundDollIdleLoop');
Â  Â  // `restartGame` function now simply calls `initializeGameForQuestion`
Â  Â  // It should ONLY be called by the "Restart" button.
Â  Â  function restartGame() {
soundDollIdleLoop.pause();
soundDollIdleLoop.currentTime = 0;

Â  Â  Â  Â  // This will set up the game questions, reset state, and start the doll.
Â  Â  Â  Â  // It does NOT replay the intro sound.
Â  Â  Â  Â  initializeGameForQuestion();
Â  Â  }

Â  Â  function quitGame() {
soundDollIdleLoop.pause();
soundDollIdleLoop.currentTime = 0;

Â  Â  Â  if (window.dollController.getState() === 'waiting') {
Â  window.dollController.playAction2(); // Play 180 to 0 only if currently at 180
}
Â  Â  Â Â 
Â  clearInterval(timer);
Â  questionEl.textContent = "You quit the game.";
Â  optionsEl.innerHTML = "";
Â  timerEl.textContent = "";
Â  quizActive = false;
Â  waitingForDoll = false;
}

Â  Â  // Handle mobile touch (outside the quiz area)
Â  Â  document.addEventListener("touchstart", function(event) {
Â  Â  Â  const quizArea = document.querySelector('.quiz-container-wrapper');
Â  Â  Â  // Check if the touch is NOT within the quiz area AND doll is in 'waiting' state
Â  Â  Â  if (!quizArea.contains(event.target) && window.dollController && window.dollController.getState() === 'waiting') {
Â  Â  Â  Â  window.dollController.playAction2();
Â  Â  Â  Â  if (window.gameController) {
Â  Â  Â  Â  Â  window.gameController.showDollSeeingMessage();
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  });
Â  </script>
</body>
</html>
